<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Contraction hierarchies | Cash Prokop-Weaver</title><meta name=keywords content="hastodo,concept,hastodo,concept"><meta name=description content="In computer science, the method of contraction hierarchies is a speed-up technique for finding the shortest-path [Shortest path problem] in a graph [Graph]. The most intuitive applications are car-navigation systems: a user wants to drive from \(A\) to \(B\) using the quickest possible route. The metric optimized here is the travel time. Intersections are represented by vertices [Vertex], the road sections connecting them by edges. The edge weights represent the time it takes to drive along this segment of the road."><meta name=author content><link rel=canonical href=http://notes.cashpw.com/posts/8d0bb3d4-18fb-4c38-a89e-11745614c640/><link crossorigin=anonymous href=/assets/css/stylesheet.min.9007c896ec996ba5ebf9426a26d82d6ed8dae8c200cf0b759a8a574a116b055b.css integrity="sha256-kAfIluyZa6Xr+UJqJtgtbtja6MIAzwt1mopXShFrBVs=" rel="preload stylesheet" as=style><link rel=icon href=http://notes.cashpw.com/favicon.ico><link rel=apple-touch-icon href=http://notes.cashpw.com/apple-touch-icon.png><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-69408538-1","auto"),ga("send","pageview"))</script><meta name=twitter:title content="Contraction hierarchies | Cash Prokop-Weaver"><meta name=twitter:description content="In computer science, the method of contraction hierarchies is a speed-up technique for finding the shortest-path [Shortest path problem] in a graph [Graph]. The most intuitive applications are car-navigation systems: a user wants to drive from \(A\) to \(B\) using the quickest possible route. The metric optimized here is the travel time. Intersections are represented by vertices [Vertex], the road sections connecting them by edges. The edge weights represent the time it takes to drive along this segment of the road."><meta property="og:title" content="Contraction hierarchies | Cash Prokop-Weaver"><meta property="og:description" content="In computer science, the method of contraction hierarchies is a speed-up technique for finding the shortest-path [Shortest path problem] in a graph [Graph]. The most intuitive applications are car-navigation systems: a user wants to drive from \(A\) to \(B\) using the quickest possible route. The metric optimized here is the travel time. Intersections are represented by vertices [Vertex], the road sections connecting them by edges. The edge weights represent the time it takes to drive along this segment of the road."><meta property="og:type" content="article"><meta property="og:url" content="http://notes.cashpw.com/posts/8d0bb3d4-18fb-4c38-a89e-11745614c640/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-05-18T11:57:00-07:00"><meta property="article:modified_time" content="2024-02-24T11:57:27-08:00"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://notes.cashpw.com/posts/"},{"@type":"ListItem","position":2,"name":"Contraction hierarchies","item":"http://notes.cashpw.com/posts/8d0bb3d4-18fb-4c38-a89e-11745614c640/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Contraction hierarchies | Cash Prokop-Weaver","name":"Contraction hierarchies","description":"In computer science, the method of contraction hierarchies is a speed-up technique for finding the shortest-path [Shortest path problem] in a graph [Graph]. The most intuitive applications are car-navigation systems: a user wants to drive from \\(A\\) to \\(B\\) using the quickest possible route. The metric optimized here is the travel time. Intersections are represented by vertices [Vertex], the road sections connecting them by edges. The edge weights represent the time it takes to drive along this segment of the road.","keywords":["hastodo","concept","hastodo","concept"],"wordCount":"3496","inLanguage":"en","datePublished":"2023-05-18T11:57:00-07:00","dateModified":"2024-02-24T11:57:27-08:00","author":[{"@type":"Person","name":"Cash Prokop-Weaver"}],"mainEntityOfPage":{"@type":"WebPage","@id":"http://notes.cashpw.com/posts/8d0bb3d4-18fb-4c38-a89e-11745614c640/"},"publisher":{"@type":"Organization","name":"Cash Prokop-Weaver","logo":{"@type":"ImageObject","url":"http://notes.cashpw.com/favicon.ico"}}}</script><script>MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["$$","$$"],["\\[","\\]"]],processEscapes:!0,processEnvironments:!0,macros:{bigo:["{\\href{/posts/big_o_notation}{O}}(#1)",1],littleo:["{\\href{/posts/little_o_notation}{o}}(#1)",1],bigtheta:["{\\href{/posts/big_theta_notation}{\\Theta}}(#1)",1],bigomega:["{\\href{/posts/big_omega_notation}{\\Omega}}(#1)",1]}},options:{skipHtmlTags:["script","noscript","style","textarea","pre"]}}</script><script async id=polyfill-script src="https://polyfill.io/v3/polyfill.min.js?features=es6" onload="polyfillScriptLoaded=!0"></script>
<script>function loadMathjaxAsync(){var e=document.createElement("script");e.src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js",e.async=!0,document.head.appendChild(e)}window.polyfillScriptLoaded?loadMathjaxAsync():document.querySelector("#polyfill-script").addEventListener("load",loadMathjaxAsync)</script><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript></head><body class="dark type-posts kind-page layout-" id=top><script data-no-instant>function switchTheme(e){switch(e){case"light":document.body.classList.remove("dark");break;case"dark":document.body.classList.add("dark");break;default:window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")}}function isDarkTheme(){return document.body.className.includes("dark")}function getPrefTheme(){return localStorage.getItem("pref-theme")}function setPrefTheme(e){switchTheme(e),localStorage.setItem("pref-theme",e)}const toggleThemeCallbacks={};toggleThemeCallbacks.main=e=>{setPrefTheme(e?"light":"dark")},window.addEventListener("toggle-theme",function(){const e=isDarkTheme();for(const t in toggleThemeCallbacks)toggleThemeCallbacks[t](e)});function toggleThemeListener(){window.dispatchEvent(new CustomEvent("toggle-theme"))}</script><script>(function(){const t="dark",e=getPrefTheme(),n=e||t;switchTheme(n)})()</script><header class=header><nav class=nav><div class=logo><a href=http://notes.cashpw.com/ accesskey=h title="Cash Prokop-Weaver (Alt + H)">Cash Prokop-Weaver</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><button id=menu-trigger aria-haspopup=menu aria-label="Menu Button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"/><line x1="3" y1="6" x2="21" y2="6"/><line x1="3" y1="18" x2="21" y2="18"/></svg></button><ul id=menu class="menu hidden"><li><a href=http://notes.cashpw.com/archives/ title=Archives>Archives</a></li><li><a href=http://notes.cashpw.com/search/ title="Search (Alt + /)" data-no-instant accesskey=/>Search</a></li></ul></nav></header><main class="main post"><article class=post-single data-pagefind-body><header class=post-header><h1 class=post-title>Contraction hierarchies</h1><div class=post-meta><span class=meta-item><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar" style="user-select:text"><rect x="3" y="4" width="18" height="18" rx="2" ry="2" style="user-select:text"/><line x1="16" y1="2" x2="16" y2="6" style="user-select:text"/><line x1="8" y1="2" x2="8" y2="6" style="user-select:text"/><line x1="3" y1="10" x2="21" y2="10" style="user-select:text"/></svg><span>2023-05-18</span></span><span class=meta-item><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentcolor" class="bi bi-pencil" viewBox="0 0 16 16"><path d="M12.146.146a.5.5.0 01.708.0l3 3a.5.5.0 010 .708l-10 10a.5.5.0 01-.168.11l-5 2a.5.5.0 01-.65-.65l2-5a.5.5.0 01.11-.168zM11.207 2.5 13.5 4.793 14.793 3.5 12.5 1.207zm1.586 3L10.5 3.207 4 9.707V10h.5a.5.5.0 01.5.5v.5h.5a.5.5.0 01.5.5v.5h.293zm-9.761 5.175-.106.106-1.528 3.821 3.821-1.528.106-.106A.5.5.0 015 12.5V12h-.5a.5.5.0 01-.5-.5V11h-.5a.5.5.0 01-.468-.325"/></svg>
<span>2024-02-24</span></span><span class=meta-item><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" stroke="currentcolor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<span>17 min</span></span></div><div class="post-meta post-references"></div></header><div class="toc side left"><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#algorithm aria-label=Algorithm>Algorithm</a><ul><li><a href=#preprocessing-phase aria-label="Preprocessing phase">Preprocessing phase</a><ul><li><a href=#node-contraction aria-label="Node contraction">Node contraction</a></li></ul></li><li><a href=#query-phase aria-label="Query phase">Query phase</a><ul><li><a href=#fix-up-down-is-backward-here-dot-check-against aria-label="FIX; up/down is backward here. Check against (Geisberger et al. 2008)">FIX; up/down is backward here. Check against (Geisberger et al. 2008)</a></li><li><a href=#example aria-label=Example>Example</a></li><li><a href=#unpacking-the-shortest-path-from-a-shortcut aria-label="Unpacking the shortest path from a shortcut">Unpacking the shortest path from a shortcut</a></li></ul></li><li><a href=#choosing-a-node-order aria-label="Choosing a node order">Choosing a node order</a><ul><li><a href=#cost-functions aria-label="Cost functions">Cost functions</a></li></ul></li></ul></li><li><a href=#describe aria-label=Describe>Describe</a><ul><ul><li><a href=#back aria-label=Back>Back</a></li><li><a href=#source aria-label=Source>Source</a></li></ul><li><a href=#algorithm aria-label=Algorithm>Algorithm</a><ul><li><a href=#back aria-label=Back>Back</a></li><li><a href=#source aria-label=Source>Source</a></li></ul></li><li><a href=#cloze aria-label=Cloze>Cloze</a><ul><li><a href=#source aria-label=Source>Source</a></li></ul></li><li><a href=#describe--contraction-hierarchies-contraction-hierarchies-dot-md aria-label="Describe (Contraction hierarchies)">Describe (Contraction hierarchies)</a><ul><li><a href=#back aria-label=Back>Back</a></li><li><a href=#source aria-label=Source>Source</a></li></ul></li><li><a href=#describe--contraction-hierarchies-contraction-hierarchies-dot-md aria-label="Describe (Contraction hierarchies)">Describe (Contraction hierarchies)</a><ul><li><a href=#back aria-label=Back>Back</a></li><li><a href=#source aria-label=Source>Source</a></li></ul></li><li><a href=#describe--contraction-hierarchies-contraction-hierarchies-dot-md aria-label="Describe (Contraction hierarchies)">Describe (Contraction hierarchies)</a><ul><li><a href=#back aria-label=Back>Back</a></li><li><a href=#source aria-label=Source>Source</a></li></ul></li><li><a href=#describe--contraction-hierarchies-contraction-hierarchies-dot-md aria-label="Describe (Contraction hierarchies)">Describe (Contraction hierarchies)</a><ul><li><a href=#back aria-label=Back>Back</a></li><li><a href=#source aria-label=Source>Source</a></li></ul></li><li><a href=#describe--contraction-hierarchies-contraction-hierarchies-dot-md aria-label="Describe (Contraction hierarchies)">Describe (Contraction hierarchies)</a><ul><li><a href=#back aria-label=Back>Back</a></li><li><a href=#source aria-label=Source>Source</a></li></ul></li><li><a href=#describe--contraction-hierarchies-contraction-hierarchies-dot-md aria-label="Describe (Contraction hierarchies)">Describe (Contraction hierarchies)</a><ul><li><a href=#back aria-label=Back>Back</a></li><li><a href=#source aria-label=Source>Source</a></li></ul></li><li><a href=#cloze--contraction-hierarchies-contraction-hierarchies-dot-md aria-label="Cloze (Contraction hierarchies)">Cloze (Contraction hierarchies)</a><ul><li><a href=#source aria-label=Source>Source</a></li></ul></li><li><a href=#cloze--contraction-hierarchies-contraction-hierarchies-dot-md aria-label="Cloze (Contraction hierarchies)">Cloze (Contraction hierarchies)</a><ul><li><a href=#source aria-label=Source>Source</a></li></ul></li><li><a href=#describe--contraction-hierarchies-contraction-hierarchies-dot-md aria-label="Describe (Contraction hierarchies)">Describe (Contraction hierarchies)</a><ul><li><a href=#back aria-label=Back>Back</a></li><li><a href=#source aria-label=Source>Source</a></li></ul></li><li><a href=#describe--contraction-hierarchies-contraction-hierarchies-dot-md aria-label="Describe (Contraction hierarchies)">Describe (Contraction hierarchies)</a><ul><li><a href=#back aria-label=Back>Back</a></li><li><a href=#source aria-label=Source>Source</a></li></ul></li><li><a href=#cloze--contraction-hierarchies-contraction-hierarchies-dot-md aria-label="Cloze (Contraction hierarchies)">Cloze (Contraction hierarchies)</a><ul><li><a href=#source aria-label=Source>Source</a></li></ul></li><li><a href=#cloze--contraction-hierarchies-contraction-hierarchies-dot-md aria-label="Cloze (Contraction hierarchies)">Cloze (Contraction hierarchies)</a><ul><li><a href=#source aria-label=Source>Source</a></li></ul></li><li><a href=#describe--contraction-hierarchies-contraction-hierarchies-dot-md aria-label="Describe (Contraction hierarchies)">Describe (Contraction hierarchies)</a><ul><li><a href=#back aria-label=Back>Back</a></li><li><a href=#source aria-label=Source>Source</a></li></ul></li><li><a href=#witness-path--contraction-hierarchies-contraction-hierarchies-dot-md aria-label="Witness path (Contraction hierarchies)">Witness path (Contraction hierarchies)</a><ul><li><a href=#source aria-label=Source>Source</a></li></ul></li><li><a href=#cloze--contraction-hierarchies-contraction-hierarchies-dot-md aria-label="Cloze (Contraction hierarchies)">Cloze (Contraction hierarchies)</a><ul><li><a href=#source aria-label=Source>Source</a></li></ul></li></ul></li><li><a href=#bibliography aria-label=Bibliography>Bibliography</a></li><li><a href=#backlinks aria-label=Backlinks>Backlinks</a></li></ul></div></details></div><div class=post-content><blockquote><p>In computer science, the method of contraction hierarchies is a speed-up technique for finding the shortest-path [<a href=/posts/555129b5-299e-4605-a2cd-9f77ebcede3d/>Shortest path problem</a>] in a graph [<a href=/posts/8bff4dfc-8073-4d45-ab89-7b3f97323327/>Graph</a>]. The most intuitive applications are car-navigation systems: a user wants to drive from \(A\) to \(B\) using the quickest possible route. The metric optimized here is the travel time. Intersections are represented by vertices [<a href=/posts/1b2526af-676d-4c0f-aa85-1ba05b8e7a93/>Vertex</a>], the road sections connecting them by edges. The edge weights represent the time it takes to drive along this segment of the road. A path from \(A\) to \(B\) is a sequence of edges (road sections); the shortest path is the one with the minimal sum of edge weights among all possible paths. The shortest path in a graph can be computed using Dijkstra&rsquo;s algorithm but, given that road networks consist of tens of millions of vertices, this is impractical. Contraction hierarchies is a speed-up method optimized to exploit properties of graphs representing road networks. The speed-up is achieved by creating shortcuts in a preprocessing phase which are then used during a shortest-path query to skip over &ldquo;unimportant&rdquo; vertices. This is based on the observation that road networks are highly hierarchical. Some intersections, for example highway junctions, are &ldquo;more important&rdquo; and higher up in the hierarchy than for example a junction leading into a dead end. Shortcuts can be used to save the precomputed distance between two important junctions such that the algorithm doesn&rsquo;t have to consider the full path between these junctions at query time. Contraction hierarchies do not know about which roads humans consider &ldquo;important&rdquo; (e.g. highways), but they are provided with the graph as input and are able to assign importance to vertices using heuristics.</p><p>[&mldr;]</p><p>The contraction hierarchies (CH) algorithm is a two-phase approach to the shortest path problem consisting of a preprocessing phase and a query phase. [&mldr;]</p><p>Consider two large cities connected by a highway. Between these two cities, there is a multitude of junctions leading to small villages and suburbs. Most drivers want to get from one city to the other – maybe as part of a larger route – and not take one of the exits on the way. In the graph representing this road layout, each intersection is represented by a node and edges are created between neighboring intersections. To calculate the distance between these two cities, the algorithm has to traverse all the edges along the way, adding up their length. Precomputing this distance once and storing it in an additional edge created between the two large cities will save calculations each time this highway has to be evaluated in a query. This additional edge is called a &ldquo;shortcut&rdquo; and has no counterpart in the real world. The contraction hierarchies algorithm has no knowledge about road types but is able to determine which shortcuts have to be created using the graph alone as input.</p><p>(<a href=#citeproc_bib_item_1>“Contraction Hierarchies” 2023</a>)</p></blockquote><h2 id=algorithm>Algorithm<a hidden class=anchor aria-hidden=true href=#algorithm>¶</a></h2><h3 id=preprocessing-phase>Preprocessing phase<a hidden class=anchor aria-hidden=true href=#preprocessing-phase>¶</a></h3><blockquote><script src=https://code.jquery.com/jquery-1.12.4.min.js integrity="sha256-ZosEbRLbNQzLpnKIkEdrPv7lOy9C27hHQ+Xp8a4MxAQ=" crossorigin=anonymous></script>
<script src=/js/load-photoswipe.js></script>
<link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.1/photoswipe.min.css integrity="sha256-sCl5PUOGMLfFYctzDW3MtRib0ctyUvI9Qsmq2wXOeBY=" crossorigin=anonymous><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.1/default-skin/default-skin.min.css integrity="sha256-BFeI1V+Vh1Rk37wswuOYn5lsTcaU96hGaI7OUVCLjPc=" crossorigin=anonymous><script src=https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.1/photoswipe.min.js integrity="sha256-UplRCs9v4KXVJvVY+p+RSo5Q4ilAUXh7kpjyIP5odyc=" crossorigin=anonymous></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.1/photoswipe-ui-default.min.js integrity="sha256-PWHOlUzc96pMc8ThwRIXPn8yH4NOLu42RQ0b9SpnpFk=" crossorigin=anonymous></script><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)"></button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><link rel=stylesheet href=/css/hugo-easy-gallery.css><div class=box><figure itemprop=associatedMedia itemscope itemtype=http://schema.org/ImageObject><div class=img><img itemprop=thumbnail src=/ox-hugo/Shortcut_in_a_shortest_path.svg></div><a href=/ox-hugo/Shortcut_in_a_shortest_path.svg itemprop=contentUrl></a></figure></div><p>(<a href=#citeproc_bib_item_1>“Contraction Hierarchies” 2023</a>)</p></blockquote><h4 id=node-contraction>Node contraction<a hidden class=anchor aria-hidden=true href=#node-contraction>¶</a></h4><blockquote><p>[Contraction hierarchies&rsquo;] basic ingredient is the contraction of a node \(v\): The node \(v\) is removed from the graph, but for any pair of arcs \((u,v)\), \((v,w)\) such that \((u,v,w)\) is a shortest path, a shortcut arc \((u,w)\) with the cost of \((u,v,w)\) is inserted. The contracted node \(v\) is called the midpoint of the shortcut. The remaining graph has one less node, a changed set of arcs (some dropped, some added), and the same shortest paths between any two remaining nodes.</p><p>(<a href=#citeproc_bib_item_1>“Contraction Hierarchies” 2023</a>)</p></blockquote><blockquote><p>When contracting a vertex \(v\) it is temporarily removed from the graph \(G\), and a shortcut is created between each pair \(\{\u,w\}\) of neighboring vertices if the shortest path from \(u\) to \(w\) contains \(v\).</p><p>(<a href=#citeproc_bib_item_1>“Contraction Hierarchies” 2023</a>)</p></blockquote><blockquote><div class=box><figure itemprop=associatedMedia itemscope itemtype=http://schema.org/ImageObject><div class=img><img itemprop=thumbnail src=/ox-hugo/2023-06-15_07-59-45_contract-intro-1.png></div><a href=/ox-hugo/2023-06-15_07-59-45_contract-intro-1.png itemprop=contentUrl></a></figure></div><div class=box><figure itemprop=associatedMedia itemscope itemtype=http://schema.org/ImageObject><div class=img><img itemprop=thumbnail src=/ox-hugo/2023-06-15_07-59-55_contract-intro-2.png></div><a href=/ox-hugo/2023-06-15_07-59-55_contract-intro-2.png itemprop=contentUrl></a></figure></div><div class=box><figure itemprop=associatedMedia itemscope itemtype=http://schema.org/ImageObject><div class=img><img itemprop=thumbnail src=/ox-hugo/2023-06-15_08-00-06_contract-intro-3.png></div><a href=/ox-hugo/2023-06-15_08-00-06_contract-intro-3.png itemprop=contentUrl></a></figure></div><p>[&mldr;]</p><p>Consider a node \(v\) and the following <code>contract</code> process:</p><p>We denote the set of all vertices with edges incoming to \(v\) as \(U\), and the set of all vertices with incoming edges from \(v\) as \(W\).</p><p>Then for each pair of vertices \((u, w)\), for \(u\) in \(U\) and \(w\) in \(W\):</p><div class=quote2><p>If the path &lt;\(u,v,w\)> is the unique shortest path from \(u\) to \(w\), we add a shortcut edge \(u,w\) to the graph with weight \(w(u, v) + w(v, w)\).</p></div><p>Then, we remove \(v\) and all of its adjacent edges from the graph.</p><p>We&rsquo;re now done contracting \(v\).</p><p>(<a href=#citeproc_bib_item_6>Lazarsfeld n.d.-b</a>)</p></blockquote><ul><li><p>When to add shortcuts</p><blockquote><p>But in general, we need a method for efficiently determining when to add a shortcut edge.</p><p>[&mldr;]</p><div class=box><figure itemprop=associatedMedia itemscope itemtype=http://schema.org/ImageObject><div class=img><img itemprop=thumbnail src=/ox-hugo/2023-06-15_08-32-52_example-1.png></div><a href=/ox-hugo/2023-06-15_08-32-52_example-1.png itemprop=contentUrl></a></figure></div><p>So we can do the following:</p><ul><li>\(\forall\; u \in U\):<ul><li>\(\forall\; w \in W\):<ul><li>Compute \(P_{w} = \operatorname{weight}(u, v) + \operatorname{weight}(v, w)\)</li></ul></li><li>\(P_{max} = \operatorname{max}(P_w)\)</li><li>\(\forall\; w \in W\):<ul><li>Perform a standard Dijkstra&rsquo;s shortest-path [<a href=/posts/477fb65f-3351-4154-a270-08c58cdcaf88/>Single-pair shortest path problem</a>] search from \(u\) [to \(w\)] on the subgraph excluding \(v\). Halt when we settle (1) a vertex with a shortest-path score \(> P_{max}\) or (2) \(w\).</li></ul></li><li>Add a shortcut if \(P_w &lt; \operatorname{distance}(u, w)\)</li></ul></li></ul><p>[paraphrased, formatting mine]</p><p>(<a href=#citeproc_bib_item_6>Lazarsfeld n.d.-b</a>)</p></blockquote><blockquote><p>How to decide if a shortcut is strictly necessary?</p><ul><li>Naive: add all possible shortcuts.</li><li>Strict: invoke Dijkstra and perform a &ldquo;witness search&rdquo; proof.</li><li>Pragmatic: invoke Dijkstra with cutoffs (max cost, max hops).</li></ul><p>(<a href=#citeproc_bib_item_4>Harabor, n.d.</a>)</p></blockquote></li></ul><ul><li><p>Example 1</p><blockquote><div class=box><figure itemprop=associatedMedia itemscope itemtype=http://schema.org/ImageObject><div class=img><img itemprop=thumbnail src=/ox-hugo/2023-06-15_08-50-04_contract-full-2.png></div><a href=/ox-hugo/2023-06-15_08-50-04_contract-full-2.png itemprop=contentUrl></a></figure></div><p>(<a href=#citeproc_bib_item_6>Lazarsfeld n.d.-b</a>)</p></blockquote><p>Let:</p><ul><li>\(v\) be \(B\)</li><li>\(U\) be \((A, C, D)\)</li><li>\(W\) be \((A, C, D)\)</li></ul><p>Steps to contract \(v (B)\):</p><ol><li>For each \(u \in U\):<ol><li>With \(u = A\):<ol><li>For each \(w \in W\):<ol><li>Skip \(w = A\)</li><li>With \(w = C\):<ol><li><p>\(P_{w} = \operatorname{weight}(u, v) + \operatorname{weight}(v, w)\)</p><p>\(P_{C} = weight(A, B) + weight(B, C) = 3 + 3 = 6\)</p></li></ol></li><li>With \(w = D\):<ol><li><p>\(P_{w} = \operatorname{weight}(u, v) + \operatorname{weight}(v, w)\)</p><p>\(P_{D} = weight(A, B) + weight(B, D) = 3 + 5 = 8\)</p></li></ol></li><li>\(P_{max} = \operatorname{max}(P_{C}, P_{D}) = \operatorname{max}(6, 8) = 8\)</li></ol></li><li>For each \(w \in W\):<ol><li>Skip \(w = A\)</li><li>With \(w = C\):<ol><li>Perform a standard Dijkstra&rsquo;s shortest-path search from \(u (A)\) to \(w ( C)\) on the subgraph excluding \(v (B)\). Halt when we settle (1) a vertex with a shortest-path score \(> P_{max}\) or (2) \(w ( C)\).<ol><li>Settle \(K\) at a cost of \(3\) (\((A, K)\))</li><li>Settle \(B\) at a cost of \(3\) (\((A, B)\))</li><li>Settle \(C\) at a cost of \(5\) (\((A, C)\))</li><li>Done!</li></ol></li><li>Don&rsquo;t add a shortcut. \(P_{C} > \operatorname{distance}(A, C)\) (\(6 > 5\))</li></ol></li><li>With \(w = D\):<ol><li>Perform a standard Dijkstra&rsquo;s shortest-path search from \(u (A)\) to \(w (D)\) on the subgraph excluding \(v (B)\). Halt when we settle (1) a vertex with a shortest-path score \(> P_{max}\) or (2) \(w (D)\).<ol><li>Settle \(K\) at a cost of \(3\) (\((A, K)\))</li><li>Settle \(B\) at a cost of \(3\) (\((A, B)\))</li><li>Settle \(C\) at a cost of \(5\) (\((A, C)\))</li><li>Settle \(J\) at a cost of \(6\) (\((A, K) + (K, J)\))</li><li>Settle \(D\) at a cost of \(7\) (\((A, C) + (C, D)\))</li></ol></li><li>Don&rsquo;t add a shortcut. \(P_{D} > \operatorname{distance}(A, D)\) (\(8 > 7\))</li></ol></li></ol></li></ol></li><li>With \(u = C\):<ol><li>Left as an exercise. No shortcuts added.</li></ol></li><li>With \(u = D\):<ol><li>Left as an exercise. No shortcuts added.</li></ol></li></ol></li></ol></li></ul><ul><li><p>Example 2</p><blockquote><div class=box><figure itemprop=associatedMedia itemscope itemtype=http://schema.org/ImageObject><div class=img><img itemprop=thumbnail src=/ox-hugo/2023-06-15_10-19-12_contract-full-5.png></div><a href=/ox-hugo/2023-06-15_10-19-12_contract-full-5.png itemprop=contentUrl></a></figure></div><p>(<a href=#citeproc_bib_item_6>Lazarsfeld n.d.-b</a>)</p></blockquote><p>Let:</p><ul><li>\(v\) be \(K\)</li><li>\(U\) be \((A, J)\)</li><li>\(W\) be \((A, J)\)</li></ul><p>Steps to contract \(v (K)\):</p><ol><li>For each \(u \in U\):<ol><li>With \(u = A\):<ol><li>For each \(w \in W\):<ol><li>Skip \(w = A\)</li><li>With \(w = J\):<ol><li><p>\(P_{w} = \operatorname{weight}(u, v) + \operatorname{weight}(v, w)\)</p><p>\(P_{J} = weight(A, K) + weight(K, J) = 3 + 3 = 6\)</p></li></ol></li><li>\(P_{max} = \operatorname{max}(P_{J}) = \operatorname{max}(6) = 6\)</li></ol></li><li>For each \(w \in W\):<ol><li>Skip \(w = A\)</li><li>With \(w = J\):<ol><li>Perform a standard Dijkstra&rsquo;s shortest-path search from \(u (A)\) to \(w (J)\) on the subgraph excluding \(v (K)\). Halt when we settle (1) a vertex with a shortest-path score \(> P_{max}\) or (2) \(w (J)\).<ol><li>Settle \(K\) at a cost of \(3\) (\((A, K)\))</li><li>Settle \(C\) at a cost of \(5\) (\((A, C)\))</li><li>Settle \(J\) at a cost of \(7\) (\((A, K) + (K, J)\))</li><li>Done!</li></ol></li><li>Add a shortcut! \(P_{C} &lt; \operatorname{distance}(A, J)\) (\(6 &lt; 7\))</li></ol></li></ol></li></ol></li><li>With \(u = J\):<ol><li>Left as an exercise. Adds a shortcut to make the shortcut connecting \((A, J)\) bidirectional.</li></ol></li></ol></li></ol></li></ul><h3 id=query-phase>Query phase<a hidden class=anchor aria-hidden=true href=#query-phase>¶</a></h3><blockquote><p>In the query phase, a bidirectional search is performed starting from the starting node \(s\) and the target node \(t\) on the original graph augmented by the shortcuts created in the preprocessing phase.</p><p>(<a href=#citeproc_bib_item_1>“Contraction Hierarchies” 2023</a>)</p></blockquote><blockquote><p>How to search the contraction hierarchy?</p><ul><li>Bi-directional search (two directions simultaneously)</li><li>Bi-directional search (one direction at a time)</li><li>Hybrid search (bi-directional first, then something else)</li><li>Contraction hierarchies can also be combined with your favourite uni-directional search scheme (<a href=#citeproc_bib_item_3>Harabor and Stuckey 2021</a>)</li></ul><p>[paraphrased]</p><p>(<a href=#citeproc_bib_item_4>Harabor, n.d.</a>)</p></blockquote><h4 id=fix-up-down-is-backward-here-dot-check-against>FIX; up/down is backward here. Check against (<a href=#citeproc_bib_item_2>Geisberger et al. 2008</a>)<a hidden class=anchor aria-hidden=true href=#fix-up-down-is-backward-here-dot-check-against>¶</a></h4><blockquote><ul><li>The upward graph only contains edges from \(v\) to \(w\) where we contracted \(v\) <strong>after</strong> \(w\).</li><li>The downward graph only contains edges from \(v\) to \(w\) where we contracted \(v\) <strong>before</strong> \(w\).</li></ul><p>[&mldr;]</p><p>For our [contraction hierarchies] query from \(s\) to \(t\), we run a forward search from \(s\) on [the upward] graph, and a backward search from \(t\) on the [downward] graph.</p><p>[paraphrased]</p><p>(<a href=#citeproc_bib_item_7>Lazarsfeld n.d.-c</a>)</p></blockquote><h4 id=example>Example<a hidden class=anchor aria-hidden=true href=#example>¶</a></h4><blockquote><div class=box><figure itemprop=associatedMedia itemscope itemtype=http://schema.org/ImageObject><div class=img><img itemprop=thumbnail src=/ox-hugo/2023-06-15_16-54-53_g-star-graph.png></div><a href=/ox-hugo/2023-06-15_16-54-53_g-star-graph.png itemprop=contentUrl></a></figure></div><p>[&mldr;]</p><p>[&mldr;] for symmetric graphs like the ones we are considering, a backward search (reversing edge directions) on \(G_{down}\) is the same as an upward search on \(G_{up}\). So from both our source and target nodes, we can perform a standard Dijkstra search on the \(G_{up}\) graph.</p><p>From our example above, let&rsquo;s say our source node is \(B\) and our target node is \(G\). Then the two respective search spaces on \(G_{up}\) will look as follows:</p><div class=box><figure itemprop=associatedMedia itemscope itemtype=http://schema.org/ImageObject><div class=img><img itemprop=thumbnail src=/ox-hugo/2023-06-15_16-54-11_upward-source.png></div><a href=/ox-hugo/2023-06-15_16-54-11_upward-source.png itemprop=contentUrl></a></figure></div><div class=box><figure itemprop=associatedMedia itemscope itemtype=http://schema.org/ImageObject><div class=img><img itemprop=thumbnail src=/ox-hugo/2023-06-15_16-57-46_upward-target.png></div><a href=/ox-hugo/2023-06-15_16-57-46_upward-target.png itemprop=contentUrl></a></figure></div><p>Although we said that <em>every</em> edge in \(G*\) is either in the \(G_{up}\) or the \(G_{down}\) graph, not all edges [&mldr;] will be relevant in the search space from a given node.</p><p>In our example above, for example, the edge \(E,D\) does exist in \(G_{up}\) since \(E\) was contracted before \(D\). But, because there is no path to \(E\) in either of the two searches from \(B\) or \(G\), we would never need to consider the edge \(E,D\).</p><p>Then on both of these upward graphs, we run a <strong><em>complete</em></strong> Dijkstra search, meaning that all nodes in <em>both</em> subgraphs must be settled. And it should be evident that in both searches, the number of settled nodes and relaxed edges is significantly reduced than if we were searching on the entire \(G*\) graph.</p><p>Moreover, because we have a complete ordering of nodes, the two search spaces can both be conceptualized as <em>DAGs</em> (directed acyclic graphs [<a href=/posts/ee7fcae8-6322-4b71-91b0-704b7c21ae3a/>Directed acyclic graph</a>]) and are inherently topologically sorted [<a href=/posts/518c35ac-35d7-4c12-9522-efb13e5be1e8/>Topological order</a>]. Consider the redrawing of the two searches that emphasizes this hierarchical nature of the contraction order:</p><div class=box><figure itemprop=associatedMedia itemscope itemtype=http://schema.org/ImageObject><div class=img><img itemprop=thumbnail src=/ox-hugo/2023-06-15_17-07-38_dag-source.png></div><a href=/ox-hugo/2023-06-15_17-07-38_dag-source.png itemprop=contentUrl></a></figure></div><div class=box><figure itemprop=associatedMedia itemscope itemtype=http://schema.org/ImageObject><div class=img><img itemprop=thumbnail src=/ox-hugo/2023-06-15_17-07-44_dag-target.png></div><a href=/ox-hugo/2023-06-15_17-07-44_dag-target.png itemprop=contentUrl></a></figure></div><p>[&mldr;]</p><p>In any case, after running two complete Dijkstra searches on \(G_{up}\) from both the source and target, we have a set of nodes that are settled in both searches. We denote this set as \(L\).</p><p>Continuing with our example from above, we see the nodes in \(L\) shaded in red with their corresponding shortest path scores:</p><div class=box><figure itemprop=associatedMedia itemscope itemtype=http://schema.org/ImageObject><div class=img><img itemprop=thumbnail src=/ox-hugo/2023-06-15_17-07-19_query-scores.png></div><a href=/ox-hugo/2023-06-15_17-07-19_query-scores.png itemprop=contentUrl></a></figure></div><p>This means the shortest path from \(B\) to \(G\) is 10 and goes through node \(H\).</p><p>[formatting mine]</p><p>(<a href=#citeproc_bib_item_7>Lazarsfeld n.d.-c</a>)</p></blockquote><h4 id=unpacking-the-shortest-path-from-a-shortcut>Unpacking the shortest path from a shortcut<a hidden class=anchor aria-hidden=true href=#unpacking-the-shortest-path-from-a-shortcut>¶</a></h4><blockquote><p>We&rsquo;re able to compute the <em>length</em> of the shortest path, but we still need to unpack the actual arcs used on that path. We can handle this during the stage of contraction when shortcut edges are added. When we add a shortcut edge from \(u\) to \(w\) during the contraction of \(v\), we store a shortcut pointer to \(v\).</p><p>We then begin unpacking the shortest path on the G*<sub>U</sub> graph from the highest order node, in both directions. We back-trace parent edge pointers as in a regular Dijkstra algorithm, and if the parent edge has a shortcut pointer, we replace the parent edge with the shortcut edge, and continue to recursively unpack the full path.</p><p>Our example query above didn&rsquo;t end up using any shortcut edges in \(G*\), but consider if we had queried the shortest path from node \(A\) to \(G\). Then, we would certainly use the shortcut edge \(A,H\). And since \(A\) is the highest-ordered node in terms of contraction time, we can visualize the &lsquo;unpacking&rsquo; of shortcut edges as:</p><div class=box><figure itemprop=associatedMedia itemscope itemtype=http://schema.org/ImageObject><div class=img><img itemprop=thumbnail src=/ox-hugo/2023-06-15_17-15-41_g-star-graph.png></div><a href=/ox-hugo/2023-06-15_17-15-41_g-star-graph.png itemprop=contentUrl></a></figure></div><div class=box><figure itemprop=associatedMedia itemscope itemtype=http://schema.org/ImageObject><div class=img><img itemprop=thumbnail src=/ox-hugo/2023-06-15_17-14-21_shortcut-unpack.png></div><a href=/ox-hugo/2023-06-15_17-14-21_shortcut-unpack.png itemprop=contentUrl></a></figure></div><p>[Paraphrased, Spelling corrected]</p><p>(<a href=#citeproc_bib_item_7>Lazarsfeld n.d.-c</a>)</p></blockquote><h3 id=choosing-a-node-order>Choosing a node order<a hidden class=anchor aria-hidden=true href=#choosing-a-node-order>¶</a></h3><blockquote><p>Our query is correct no matter the order in which nodes were contracted, but a good node ordering has major implications for the performance of the queries. The order in which nodes are contracted affects the shortcut edges that do or don&rsquo;t get added in G*. And as it&rsquo;s been mentioned before, too many shortcut edges means too dense a G* graph and slower queries as a result.</p><p>(<a href=#citeproc_bib_item_5>Lazarsfeld n.d.-a</a>)</p></blockquote><h4 id=cost-functions>Cost functions<a hidden class=anchor aria-hidden=true href=#cost-functions>¶</a></h4><ul><li><p>Edge difference</p><blockquote><p>It turns out that the main function used to determine this cost involves simulating the contraction of each node. Given that all edges incident to a node are removed during contraction, we&rsquo;re interested in the edge difference of a node, which is the difference between the number of original edges removed and the number of shortcut edges added.</p><p>[&mldr;]</p><p>Using our original, arbitrary node ordering, we only added 3 shortcut edges. In the example, B was the first node we contracted, and it didn&rsquo;t require any shortcuts to be added. In other words, the edge difference of B is -3.</p><p>But what if we had first contracted J first? Compare what choosing J over B looks like:</p><div class=box><figure itemprop=associatedMedia itemscope itemtype=http://schema.org/ImageObject><div class=img><img itemprop=thumbnail src=/ox-hugo/2023-06-16_16-14-51_order-example-1.png></div><a href=/ox-hugo/2023-06-16_16-14-51_order-example-1.png itemprop=contentUrl></a></figure></div><div class=box><figure itemprop=associatedMedia itemscope itemtype=http://schema.org/ImageObject><div class=img><img itemprop=thumbnail src=/ox-hugo/2023-06-16_16-15-04_order-example-3.png></div><a href=/ox-hugo/2023-06-16_16-15-04_order-example-3.png itemprop=contentUrl></a></figure></div><p>So clearly J has a much greater edge difference than B, and so J is less attractive to contract early on.</p><p>[&mldr;]</p><p>But consider that after we begin contracting nodes, the edge difference for other nodes can be affected. If we wanted to strictly adhere to an ordering based on edge difference, we would need to recompute the edge difference for every remaining node in the graph after each contraction. Of course, this would end up taking quadratic time, so it isn&rsquo;t feasible. Instead, we can use the lazy update heuristic [&mldr;]</p><p>[&mldr;]</p><p>Before contracting the next minimum node, we recompute its edge difference. If it&rsquo;s still the smallest in the priority queue [<a href=/posts/6f787120-13bb-405a-bfca-060df6d80b14/>Priority queue</a>], we can go ahead and actually contract it. If its edge difference is no longer the min, then we update its cost and rebalance our [priority queue]. We then check the next minimum node and continue this process.</p><p>(<a href=#citeproc_bib_item_5>Lazarsfeld n.d.-a</a>)</p></blockquote></li></ul><ul><li><p>Contracted neighbors</p><blockquote><p>[&mldr;] we might consider the idea of uniformity to be important when contracting nodes. This means varying the location of nodes in terms of their contraction order.</p><p>Conceptually, we wouldn&rsquo;t want to contract all nodes in a small region of the graph consecutively because we could risk adding too many wasteful shortcuts. In our original example, we had a pretty good ordering partly because nodes in different parts of the graph were contracted each round.</p><p>So an additional term to consider is the number of contracted neighbors each node has. This just involves counting the number of neighbors in the original graph that have already been contracted. When dealing with multiple terms like contracted neighbors and edge difference to determine cost, we would use a linear combination of terms.</p><p>(<a href=#citeproc_bib_item_5>Lazarsfeld n.d.-a</a>)</p></blockquote></li></ul><h2 id=describe>Describe<a hidden class=anchor aria-hidden=true href=#describe>¶</a></h2><table><thead><tr><th>position</th><th>ease</th><th>box</th><th>interval</th><th>due</th></tr></thead><tbody><tr><td>front</td><td>2.50</td><td>5</td><td>36.62</td><td>2023-07-22T04:17:01Z</td></tr><tr><td>back</td><td>2.65</td><td>4</td><td>15.61</td><td>2023-06-26T06:42:13Z</td></tr></tbody></table><p><a href=/posts/8d0bb3d4-18fb-4c38-a89e-11745614c640/>Contraction hierarchies</a></p><h4 id=back>Back<a hidden class=anchor aria-hidden=true href=#back>¶</a></h4><p>A speed up method for calculating the shortest path between nodes in a graph based on the assumption that some vertices are more important than others.</p><h4 id=source>Source<a hidden class=anchor aria-hidden=true href=#source>¶</a></h4><p>(<a href=#citeproc_bib_item_1>“Contraction Hierarchies” 2023</a>)</p><h3 id=algorithm>Algorithm<a hidden class=anchor aria-hidden=true href=#algorithm>¶</a></h3><table><thead><tr><th>position</th><th>ease</th><th>box</th><th>interval</th><th>due</th></tr></thead><tbody><tr><td>front</td><td>2.20</td><td>4</td><td>12.26</td><td>2024-03-04T23:49:50Z</td></tr><tr><td>back</td><td>2.5</td><td>-1</td><td>0</td><td>2023-06-15T15:20:40Z</td></tr></tbody></table><p>Node contraction in <a href=/posts/8d0bb3d4-18fb-4c38-a89e-11745614c640/>Contraction hierarchies</a></p><h4 id=back>Back<a hidden class=anchor aria-hidden=true href=#back>¶</a></h4><p>Given:</p><ul><li>\(v\): the vertex to contract</li><li>\(U\): the set of all vertices with edges incoming to \(v\)</li><li>\(W\): the set of all vertices with incoming edges from \(v\)</li></ul><p>Steps:</p><ol><li>\(\forall\; u \in U\):<ol><li>\(\forall\; w \in W\):<ol><li>Compute \(P_{w} = \operatorname{weight}(u, v) + \operatorname{weight}(v, w)\)</li></ol></li><li>\(P_{max} = \operatorname{max}(P_w)\)</li><li>\(\forall\; w \in W\):<ol><li>Perform a standard Dijkstra&rsquo;s shortest-path [<a href=/posts/477fb65f-3351-4154-a270-08c58cdcaf88/>Single-pair shortest path problem</a>] search from \(u\) to \(w\) on the subgraph excluding \(v\). Halt when we settle (1) a vertex with a shortest-path score \(> P_{max}\) or (2) \(w\).</li></ol></li><li>Add a shortcut if \(P_w &lt; \operatorname{distance}(u, w)\)</li></ol></li></ol><h4 id=source>Source<a hidden class=anchor aria-hidden=true href=#source>¶</a></h4><p>(<a href=#citeproc_bib_item_6>Lazarsfeld n.d.-b</a>)</p><h3 id=cloze>Cloze<a hidden class=anchor aria-hidden=true href=#cloze>¶</a></h3><table><thead><tr><th>position</th><th>ease</th><th>box</th><th>interval</th><th>due</th></tr></thead><tbody><tr><td>0</td><td>2.50</td><td>5</td><td>35.59</td><td>2024-03-12T06:45:40Z</td></tr><tr><td>1</td><td>2.5</td><td>-1</td><td>0</td><td>2023-06-15T15:21:11Z</td></tr></tbody></table><p>{{Node contraction}@0} is the process of {{finding shortcuts in a graph in <a href=/posts/8d0bb3d4-18fb-4c38-a89e-11745614c640/>Contraction hierarchies</a>}@1}.</p><h4 id=source>Source<a hidden class=anchor aria-hidden=true href=#source>¶</a></h4><p>(<a href=#citeproc_bib_item_1>“Contraction Hierarchies” 2023</a>)</p><h3 id=describe--contraction-hierarchies-contraction-hierarchies-dot-md>Describe (<a href=/posts/8d0bb3d4-18fb-4c38-a89e-11745614c640/>Contraction hierarchies</a>)<a hidden class=anchor aria-hidden=true href=#describe--contraction-hierarchies-contraction-hierarchies-dot-md>¶</a></h3><table><thead><tr><th>position</th><th>ease</th><th>box</th><th>interval</th><th>due</th></tr></thead><tbody><tr><td>front</td><td>2.20</td><td>5</td><td>27.43</td><td>2024-03-18T08:19:33Z</td></tr><tr><td>back</td><td>2.5</td><td>-1</td><td>0</td><td>2023-06-15T15:30:07Z</td></tr></tbody></table><p>When do we contract a vertex, \(v\)?</p><h4 id=back>Back<a hidden class=anchor aria-hidden=true href=#back>¶</a></h4><ul><li>Given a given vertex, \(v\)</li><li>Let \(U\) be the set of vertices with edges going to \(v\)</li><li>Let \(W\) be the set of vertices with edges coming from \(v\)</li></ul><p>We contract \(v\) when the path \(u, v, w\) is the shortest path from \(u\) to \(w\).</p><h4 id=source>Source<a hidden class=anchor aria-hidden=true href=#source>¶</a></h4><p>(<a href=#citeproc_bib_item_6>Lazarsfeld n.d.-b</a>)</p><h3 id=describe--contraction-hierarchies-contraction-hierarchies-dot-md>Describe (<a href=/posts/8d0bb3d4-18fb-4c38-a89e-11745614c640/>Contraction hierarchies</a>)<a hidden class=anchor aria-hidden=true href=#describe--contraction-hierarchies-contraction-hierarchies-dot-md>¶</a></h3><table><thead><tr><th>position</th><th>ease</th><th>box</th><th>interval</th><th>due</th></tr></thead><tbody><tr><td>front</td><td>2.50</td><td>6</td><td>87.92</td><td>2024-05-18T13:51:31Z</td></tr><tr><td>back</td><td>2.5</td><td>-1</td><td>0</td><td>2023-06-15T15:49:21Z</td></tr></tbody></table><p>How do we ensure \(u, v, w\) is the shortest path from \(u\) to \(w\)?</p><h4 id=back>Back<a hidden class=anchor aria-hidden=true href=#back>¶</a></h4><p>Perform a local <a href=/posts/668cbbcc-170b-42c8-b92b-75f6868a0138/>Dijkstra&rsquo;s algorithm</a> and compare the shortest path found excluding \(v\) to the shortest path found which includes \(v\).</p><h4 id=source>Source<a hidden class=anchor aria-hidden=true href=#source>¶</a></h4><p>(<a href=#citeproc_bib_item_6>Lazarsfeld n.d.-b</a>)</p><h3 id=describe--contraction-hierarchies-contraction-hierarchies-dot-md>Describe (<a href=/posts/8d0bb3d4-18fb-4c38-a89e-11745614c640/>Contraction hierarchies</a>)<a hidden class=anchor aria-hidden=true href=#describe--contraction-hierarchies-contraction-hierarchies-dot-md>¶</a></h3><table><thead><tr><th>position</th><th>ease</th><th>box</th><th>interval</th><th>due</th></tr></thead><tbody><tr><td>front</td><td>2.35</td><td>7</td><td>203.08</td><td>2024-09-12T17:46:17Z</td></tr><tr><td>back</td><td>2.5</td><td>-1</td><td>0</td><td>2023-06-16T23:05:25Z</td></tr></tbody></table><p>How to extract the shortest path through an added shortcut?</p><h4 id=back>Back<a hidden class=anchor aria-hidden=true href=#back>¶</a></h4><p>We store a pointer to the interim vertex, \(v\), when we contract \(u, v, w\) into \(u, w\).</p><h4 id=source>Source<a hidden class=anchor aria-hidden=true href=#source>¶</a></h4><p>(<a href=#citeproc_bib_item_7>Lazarsfeld n.d.-c</a>)</p><h3 id=describe--contraction-hierarchies-contraction-hierarchies-dot-md>Describe (<a href=/posts/8d0bb3d4-18fb-4c38-a89e-11745614c640/>Contraction hierarchies</a>)<a hidden class=anchor aria-hidden=true href=#describe--contraction-hierarchies-contraction-hierarchies-dot-md>¶</a></h3><table><thead><tr><th>position</th><th>ease</th><th>box</th><th>interval</th><th>due</th></tr></thead><tbody><tr><td>front</td><td>1.90</td><td>3</td><td>6.00</td><td>2024-02-20T15:00:32Z</td></tr><tr><td>back</td><td>2.50</td><td>1</td><td>1.00</td><td>2024-02-14T14:39:30Z</td></tr></tbody></table><p>Heuristics for choosing the order to contract vertices.</p><h4 id=back>Back<a hidden class=anchor aria-hidden=true href=#back>¶</a></h4><ul><li><a href=#edge-difference>Edge difference</a></li><li><a href=#contracted-neighbors>Contracted neighbors</a></li></ul><h4 id=source>Source<a hidden class=anchor aria-hidden=true href=#source>¶</a></h4><p>(<a href=#citeproc_bib_item_5>Lazarsfeld n.d.-a</a>)</p><h3 id=describe--contraction-hierarchies-contraction-hierarchies-dot-md>Describe (<a href=/posts/8d0bb3d4-18fb-4c38-a89e-11745614c640/>Contraction hierarchies</a>)<a hidden class=anchor aria-hidden=true href=#describe--contraction-hierarchies-contraction-hierarchies-dot-md>¶</a></h3><table><thead><tr><th>position</th><th>ease</th><th>box</th><th>interval</th><th>due</th></tr></thead><tbody><tr><td>front</td><td>2.20</td><td>5</td><td>25.66</td><td>2024-03-02T08:28:50Z</td></tr><tr><td>back</td><td>2.5</td><td>-1</td><td>0</td><td>2023-06-16T23:22:44Z</td></tr></tbody></table><p>Edge difference</p><h4 id=back>Back<a hidden class=anchor aria-hidden=true href=#back>¶</a></h4><ul><li>Heuristic for deciding the order to contract vertices in a graph</li><li>Ranks vertices by the number of edges removed by contraction</li><li>\(\text{score} = \text{edges removed} + \text{edges (shortcuts) added}\)</li></ul><h4 id=source>Source<a hidden class=anchor aria-hidden=true href=#source>¶</a></h4><p>(<a href=#citeproc_bib_item_5>Lazarsfeld n.d.-a</a>)</p><h3 id=describe--contraction-hierarchies-contraction-hierarchies-dot-md>Describe (<a href=/posts/8d0bb3d4-18fb-4c38-a89e-11745614c640/>Contraction hierarchies</a>)<a hidden class=anchor aria-hidden=true href=#describe--contraction-hierarchies-contraction-hierarchies-dot-md>¶</a></h3><table><thead><tr><th>position</th><th>ease</th><th>box</th><th>interval</th><th>due</th></tr></thead><tbody><tr><td>front</td><td>2.20</td><td>6</td><td>67.93</td><td>2024-02-14T16:02:48Z</td></tr><tr><td>back</td><td>2.50</td><td>1</td><td>1.00</td><td>2024-02-08T15:06:13Z</td></tr></tbody></table><p>Contracted neighbors</p><h4 id=back>Back<a hidden class=anchor aria-hidden=true href=#back>¶</a></h4><ul><li>Heuristic for deciding the order to contract vertices in a graph</li><li>Ranks vertices by the proximity of other contracted vertices</li></ul><h4 id=source>Source<a hidden class=anchor aria-hidden=true href=#source>¶</a></h4><p>(<a href=#citeproc_bib_item_5>Lazarsfeld n.d.-a</a>)</p><h3 id=cloze--contraction-hierarchies-contraction-hierarchies-dot-md>Cloze (<a href=/posts/8d0bb3d4-18fb-4c38-a89e-11745614c640/>Contraction hierarchies</a>)<a hidden class=anchor aria-hidden=true href=#cloze--contraction-hierarchies-contraction-hierarchies-dot-md>¶</a></h3><table><thead><tr><th>position</th><th>ease</th><th>box</th><th>interval</th><th>due</th></tr></thead><tbody><tr><td>0</td><td>2.35</td><td>3</td><td>6.00</td><td>2023-12-11T14:25:22Z</td></tr></tbody></table><p>We should contract vertices in {{ascending order}{direction}@0} of edge difference.</p><h4 id=source>Source<a hidden class=anchor aria-hidden=true href=#source>¶</a></h4><p>(<a href=#citeproc_bib_item_5>Lazarsfeld n.d.-a</a>)</p><h3 id=cloze--contraction-hierarchies-contraction-hierarchies-dot-md>Cloze (<a href=/posts/8d0bb3d4-18fb-4c38-a89e-11745614c640/>Contraction hierarchies</a>)<a hidden class=anchor aria-hidden=true href=#cloze--contraction-hierarchies-contraction-hierarchies-dot-md>¶</a></h3><table><thead><tr><th>position</th><th>ease</th><th>box</th><th>interval</th><th>due</th></tr></thead><tbody><tr><td>0</td><td>2.50</td><td>5</td><td>33.68</td><td>2024-01-23T07:41:18Z</td></tr></tbody></table><p>We should contract vertices with {{fewer}{comparison}@0} contracted neighbors first.</p><h4 id=source>Source<a hidden class=anchor aria-hidden=true href=#source>¶</a></h4><p>(<a href=#citeproc_bib_item_5>Lazarsfeld n.d.-a</a>)</p><h3 id=describe--contraction-hierarchies-contraction-hierarchies-dot-md>Describe (<a href=/posts/8d0bb3d4-18fb-4c38-a89e-11745614c640/>Contraction hierarchies</a>)<a hidden class=anchor aria-hidden=true href=#describe--contraction-hierarchies-contraction-hierarchies-dot-md>¶</a></h3><table><thead><tr><th>position</th><th>ease</th><th>box</th><th>interval</th><th>due</th></tr></thead><tbody><tr><td>front</td><td>2.20</td><td>7</td><td>130.70</td><td>2024-03-27T08:31:39Z</td></tr><tr><td>back</td><td>2.50</td><td>2</td><td>2.00</td><td>2023-08-25T16:36:13Z</td></tr></tbody></table><p>Lazy update in the context of vertex ordering</p><h4 id=back>Back<a hidden class=anchor aria-hidden=true href=#back>¶</a></h4><ul><li>Contracting any vertex may change the optimal contraction ordering of the remaining vertices</li><li>Re-compute the rank/weight after popping the next vertex off the <a href=/posts/6f787120-13bb-405a-bfca-060df6d80b14/>Priority queue</a></li></ul><h4 id=source>Source<a hidden class=anchor aria-hidden=true href=#source>¶</a></h4><p>(<a href=#citeproc_bib_item_5>Lazarsfeld n.d.-a</a>)</p><h3 id=describe--contraction-hierarchies-contraction-hierarchies-dot-md>Describe (<a href=/posts/8d0bb3d4-18fb-4c38-a89e-11745614c640/>Contraction hierarchies</a>)<a hidden class=anchor aria-hidden=true href=#describe--contraction-hierarchies-contraction-hierarchies-dot-md>¶</a></h3><table><thead><tr><th>position</th><th>ease</th><th>box</th><th>interval</th><th>due</th></tr></thead><tbody><tr><td>front</td><td>2.50</td><td>6</td><td>87.37</td><td>2024-05-21T00:41:19Z</td></tr><tr><td>back</td><td>2.5</td><td>-1</td><td>0</td><td>2023-06-20T15:35:52Z</td></tr></tbody></table><p>Query phase</p><h4 id=back>Back<a hidden class=anchor aria-hidden=true href=#back>¶</a></h4><ul><li>Performs a bi-directional <a href=/posts/668cbbcc-170b-42c8-b92b-75f6868a0138/>Dijkstra</a> search for shortest path from \(s\) to \(t\)<ul><li>Forward search on upward graph from \(s\)</li><li>Backward search on downward graph from \(t\)</li></ul></li></ul><h4 id=source>Source<a hidden class=anchor aria-hidden=true href=#source>¶</a></h4><p>(<a href=#citeproc_bib_item_7>Lazarsfeld n.d.-c</a>)</p><h3 id=cloze--contraction-hierarchies-contraction-hierarchies-dot-md>Cloze (<a href=/posts/8d0bb3d4-18fb-4c38-a89e-11745614c640/>Contraction hierarchies</a>)<a hidden class=anchor aria-hidden=true href=#cloze--contraction-hierarchies-contraction-hierarchies-dot-md>¶</a></h3><table><thead><tr><th>position</th><th>ease</th><th>box</th><th>interval</th><th>due</th></tr></thead><tbody><tr><td>0</td><td>2.20</td><td>2</td><td>2.00</td><td>2023-11-01T14:52:43Z</td></tr><tr><td>1</td><td>2.5</td><td>-1</td><td>0</td><td>2023-06-20T15:38:35Z</td></tr></tbody></table><p>{{\(G_{up}\)}@0}, a subgraph of \(G\), contains only edges from \(v\) to \(w\) {{where we contracted \(w\) <strong>after</strong> \(v\)}{condition}@1}</p><h4 id=source>Source<a hidden class=anchor aria-hidden=true href=#source>¶</a></h4><p>(<a href=#citeproc_bib_item_7>Lazarsfeld n.d.-c</a>)</p><h3 id=cloze--contraction-hierarchies-contraction-hierarchies-dot-md>Cloze (<a href=/posts/8d0bb3d4-18fb-4c38-a89e-11745614c640/>Contraction hierarchies</a>)<a hidden class=anchor aria-hidden=true href=#cloze--contraction-hierarchies-contraction-hierarchies-dot-md>¶</a></h3><table><thead><tr><th>position</th><th>ease</th><th>box</th><th>interval</th><th>due</th></tr></thead><tbody><tr><td>0</td><td>2.65</td><td>4</td><td>15.02</td><td>2023-12-13T15:19:55Z</td></tr><tr><td>1</td><td>2.5</td><td>-1</td><td>0</td><td>2023-06-20T15:39:08Z</td></tr></tbody></table><p>{{\(G_{down}\)}@0}, a subgraph of \(G\), contains only edges from \(v\) to \(w\) {{where we contracted \(v\) <strong>before</strong> \(w\)}{condition}@1}</p><h4 id=source>Source<a hidden class=anchor aria-hidden=true href=#source>¶</a></h4><p>(<a href=#citeproc_bib_item_7>Lazarsfeld n.d.-c</a>)</p><h3 id=describe--contraction-hierarchies-contraction-hierarchies-dot-md>Describe (<a href=/posts/8d0bb3d4-18fb-4c38-a89e-11745614c640/>Contraction hierarchies</a>)<a hidden class=anchor aria-hidden=true href=#describe--contraction-hierarchies-contraction-hierarchies-dot-md>¶</a></h3><table><thead><tr><th>position</th><th>ease</th><th>box</th><th>interval</th><th>due</th></tr></thead><tbody><tr><td>front</td><td>2.20</td><td>7</td><td>144.13</td><td>2024-06-15T17:56:54Z</td></tr><tr><td>back</td><td>2.5</td><td>-1</td><td>0</td><td>2023-06-20T15:42:14Z</td></tr></tbody></table><p>How to unpack the shortest path from a shortcut</p><h4 id=back>Back<a hidden class=anchor aria-hidden=true href=#back>¶</a></h4><p>Store a pointer to the contracted node, \(v\), whenever we contract \(u, v, w\) into \(u, w\).</p><h4 id=source>Source<a hidden class=anchor aria-hidden=true href=#source>¶</a></h4><p>(<a href=#citeproc_bib_item_7>Lazarsfeld n.d.-c</a>)</p><h3 id=witness-path--contraction-hierarchies-contraction-hierarchies-dot-md>Witness path (<a href=/posts/8d0bb3d4-18fb-4c38-a89e-11745614c640/>Contraction hierarchies</a>)<a hidden class=anchor aria-hidden=true href=#witness-path--contraction-hierarchies-contraction-hierarchies-dot-md>¶</a></h3><table><thead><tr><th>position</th><th>ease</th><th>box</th><th>interval</th><th>due</th></tr></thead><tbody><tr><td>front</td><td>2.20</td><td>4</td><td>12.76</td><td>2024-03-04T10:08:23Z</td></tr><tr><td>back</td><td>2.5</td><td>-1</td><td>0</td><td>2023-06-20T15:44:41Z</td></tr></tbody></table><p>A path \(u, \dots, w\) around \(v\) with cost smaller than the cost of \(u, v, w\).</p><h4 id=source>Source<a hidden class=anchor aria-hidden=true href=#source>¶</a></h4><p>(<a href=#citeproc_bib_item_1>“Contraction Hierarchies” 2023</a>)</p><h3 id=cloze--contraction-hierarchies-contraction-hierarchies-dot-md>Cloze (<a href=/posts/8d0bb3d4-18fb-4c38-a89e-11745614c640/>Contraction hierarchies</a>)<a hidden class=anchor aria-hidden=true href=#cloze--contraction-hierarchies-contraction-hierarchies-dot-md>¶</a></h3><table><thead><tr><th>position</th><th>ease</th><th>box</th><th>interval</th><th>due</th></tr></thead><tbody><tr><td>0</td><td>2.50</td><td>6</td><td>96.97</td><td>2024-05-02T14:01:46Z</td></tr></tbody></table><p>Contraction is {{iterative}{process}@0}</p><h4 id=source>Source<a hidden class=anchor aria-hidden=true href=#source>¶</a></h4><p>(<a href=#citeproc_bib_item_1>“Contraction Hierarchies” 2023</a>)</p><h2 id=bibliography>Bibliography<a hidden class=anchor aria-hidden=true href=#bibliography>¶</a></h2><style>.csl-entry{text-indent:-1.5em;margin-left:1.5em}</style><div class=csl-bib-body><div class=csl-entry><a id=citeproc_bib_item_1></a>“Contraction Hierarchies.” 2023. <i>Wikipedia</i>, May. <a href="https://en.wikipedia.org/w/index.php?title=Contraction_hierarchies&oldid=1153438478">https://en.wikipedia.org/w/index.php?title=Contraction_hierarchies&#38;oldid=1153438478</a>.</div><div class=csl-entry><a id=citeproc_bib_item_2></a>Geisberger, Robert, Peter Sanders, Dominik Schultes, and Daniel Delling. 2008. “Contraction Hierarchies: Faster and Simpler Hierarchical Routing in Road Networks.” In <i>Experimental Algorithms</i>, edited by Catherine C. McGeoch, 5038:319–33. Berlin, Heidelberg: Springer Berlin Heidelberg. <a href=https://doi.org/10.1007/978-3-540-68552-4_24>https://doi.org/10.1007/978-3-540-68552-4_24</a>.</div><div class=csl-entry><a id=citeproc_bib_item_3></a>Harabor, Daniel, and Peter Stuckey. 2021. “Forward Search in Contraction Hierarchies.” <i>Proceedings of the International Symposium on Combinatorial Search</i> 9 (1): 55–62. <a href=https://doi.org/10.1609/socs.v9i1.18454>https://doi.org/10.1609/socs.v9i1.18454</a>.</div><div class=csl-entry><a id=citeproc_bib_item_4></a>Harabor, Daniel D. n.d. “An Introduction to Contraction Hierarchies.”</div><div class=csl-entry><a id=citeproc_bib_item_5></a>Lazarsfeld, John. n.d.-a. “Core Components of CH: Choosing a Node Order.” <i>Contraction Hierarchies Guide</i>. Accessed June 16, 2023. <a href=https://jlazarsfeld.github.io//ch.150.project/sections/12-node-order/>https://jlazarsfeld.github.io//ch.150.project/sections/12-node-order/</a>.</div><div class=csl-entry><a id=citeproc_bib_item_6></a>———. n.d.-b. “Core Components of CH: Node Contraction.” <i>Contraction Hierarchies Guide</i>. Accessed June 15, 2023. <a href=https://jlazarsfeld.github.io//ch.150.project/sections/8-contraction/>https://jlazarsfeld.github.io//ch.150.project/sections/8-contraction/</a>.</div><div class=csl-entry><a id=citeproc_bib_item_7></a>———. n.d.-c. “Core Components of CH: The Modified, Bidirectional Query.” <i>Contraction Hierarchies Guide</i>. Accessed June 15, 2023. <a href=https://jlazarsfeld.github.io//ch.150.project/sections/10-ch-query/>https://jlazarsfeld.github.io//ch.150.project/sections/10-ch-query/</a>.</div></div><h2 id=backlinks>Backlinks<a hidden class=anchor aria-hidden=true href=#backlinks>¶</a></h2><ul><li><a href=/posts/41a0db19-6156-4242-8078-673cbd1e550e/>Customizable route planning</a></li><li><a href=/posts/713a5208-36bb-4266-9d70-d34cd6079ce4/>Robert Geisberger, Peter Sanders, Dominik Schultes, Daniel Delling | Contraction Hierarchies: Faster and Simpler Hierarchical Routing in Road Networks</a></li></ul></div><footer class=post-footer><script>const backlinkHeader=document.getElementById("backlinks");if(backlinkHeader){const t=document.createElement("h4");t.innerHTML=backlinkHeader.innerHTML;const n=backlinkHeader.nextElementSibling;console.log(n);const e=document.createElement("aside");e.setAttribute("class","backlinks toc side right"),backlinkHeader.parentNode.insertBefore(e,backlinkHeader),e.appendChild(t),e.appendChild(n),backlinkHeader.remove(),t.id="backlinks"}</script><script src=/js/citations/custom.js></script></footer></article></main><footer class=footer><span>&copy; 2024 <a href=http://notes.cashpw.com/>Cash Prokop-Weaver</a></span><span style=display:inline-block;margin-left:1em>
<a href=https://creativecommons.org/licenses/by-sa/4.0/>CC BY-SA</a></span>
<span style=display:inline-block;margin-left:1em>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
    <a href=https://github.com/reorx/hugo-PaperModX/ rel=noopener target=_blank>PaperModX</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>const menuTrigger=document.querySelector("#menu-trigger"),menu=document.querySelector(".menu");menuTrigger.addEventListener("click",function(){menu.classList.toggle("hidden")}),document.body.addEventListener("click",function(e){menuTrigger.contains(e.target)||menu.classList.add("hidden")});const mobileWidthCutoffInPixels=768;window.screen.width>mobileWidthCutoffInPixels&&document.querySelectorAll(".toc").forEach(e=>{e.querySelectorAll(":scope > details").forEach(e=>{e.setAttribute("open","")})})</script><script>(function(){const t=""=="1";if(t)return;let e=document.getElementById("theme-toggle");e.removeEventListener("click",toggleThemeListener),e.addEventListener("click",toggleThemeListener)})()</script><script>(function(){let e=document.getElementById("menu");e&&(e.scrollLeft=localStorage.getItem("menu-scroll-position"),e.onscroll=function(){localStorage.setItem("menu-scroll-position",e.scrollLeft)});const t=""=="1",n=""=="1";if(window.matchMedia("(prefers-reduced-motion: reduce)").matches||t||n)return;document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})})()</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>if(window.scrollListeners)for(const e of scrollListeners)window.removeEventListener("scroll",e);window.scrollListeners=[]</script><script src=/js/medium-zoom.min.js data-no-instant></script>
<script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerText="copy";function s(){t.innerText="copied!",setTimeout(()=>{t.innerText="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script><script>(function(){const a="1"=="1";if(!a)return;if(!document.querySelector(".toc")){console.log("no toc found, ignore toc scroll");return}const r=window.scrollListeners,t=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id]"),n="active";let e=t[0];o(e).classList.add(n);const c=()=>{const s=[];for(const e of t)if(l(e)<5)s.push(e);else break;s.length>0?newActiveHeading=s[s.length-1]:newActiveHeading=t[0],e!=newActiveHeading&&(o(e).classList.remove(n),e=newActiveHeading,o(e).classList.add(n))};let s=null;const i=()=>{s!==null&&clearTimeout(s),s=setTimeout(c,50)};window.addEventListener("scroll",i,!1),r.push(i);function o(e){const t=encodeURI(e.getAttribute("id")).toLowerCase();return document.querySelector(`.toc ul li a[href="#${t}"]`)}function l(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect();return t.top}})()</script></body></html>